{"name":"Csc253-midterm","tagline":"Midterm Blogpost. Jinze An and Christian Djoe","body":"<html>\r\n<body>\r\n<h1>Table of Contents</h1>\r\n<ul>\r\n<li><a href=\"#Introduction\">Introduction</a></li>\r\n<ul>\r\n<li><a href=\"#Execution\">Execution Overview</a></li>\r\n</ul>\r\n<li><a href=\"#Core\">Core Mechanics</a></li>\r\n<ul>\r\n<li><a href=\"#SETUP_LOOP\">SETUP_LOOP</a></li>\r\n<li><a href=\"#COMPARE_OP\">COMPARE_OP</a></li>\r\n<li><a href=\"#INPLACE_ADD\">INPLACE_ADD</a></li>\r\n</ul>\r\n<li><a href=\"#Control\">Control Flow</a></li>\r\n<ul>\r\n<li><a href=\"#POP_JUMP\">POP_JUMP_IF_FALSE</a></li>\r\n<li><a href=\"#JUMP\">JUMP_ABSOLUTE</a></li>\r\n</ul>\r\n<li><a href=\"#Clean\">Clean Up</a></li>\r\n<ul>\r\n<li><a href=\"#POP_BLOCK\">POP_BLOCK</a></li>\r\n</ul>\r\n</ul>\r\n<h1 id=\"Introduction\">Introduction</h1>\r\n<p>\r\nTo trace the mechanics of a Python while loop, we wrote a very basic script\r\nthat involves incrementing a counter a few times in a while loop.\r\n</p>\r\n<p>\r\nThe code is as follows:\r\n</p>\r\n<pre><code>\r\n  x = 1\r\n  y = 5\r\n  while x &lt; y:\r\n    x += 1\r\n</code></pre>\r\n<p>\r\nThe disassembled code is as follows:  \r\n</p>\r\n<pre><code>\r\n  1           0 LOAD_CONST               0 (1)\r\n              3 STORE_NAME               0 (x)\r\n\r\n  2           6 LOAD_CONST               1 (5)\r\n              9 STORE_NAME               1 (y)\r\n\r\n  3          12 SETUP_LOOP              26 (to 41)\r\n        >>   15 LOAD_NAME                0 (x)\r\n             18 LOAD_NAME                1 (y)\r\n             21 COMPARE_OP               0 (&lt;)\r\n             24 POP_JUMP_IF_FALSE       40\r\n\r\n  4          27 LOAD_NAME                0 (x)\r\n             30 LOAD_CONST               0 (1)\r\n             33 INPLACE_ADD         \r\n             34 STORE_NAME               0 (x)\r\n             37 JUMP_ABSOLUTE           15\r\n        >>   40 POP_BLOCK           \r\n        >>   41 LOAD_CONST               2 (None)\r\n             44 RETURN_VALUE        \r\n</code></pre>\r\n<p>\r\nMost if not all of those opcodes should look very familiar, as they have been covered\r\neither in class or in previous assignments. The bytes that make up the core of the \r\nwhile loop functionality range from byte 12 to byte 40. The other byte codes are trivial\r\nvalue and name management and program exit.\r\n</p>\r\n<h2 id=\"Execution\">Execution Overview</h2>\r\n<p>\r\nIn terms of what the program will actually step through:<br/>\r\nOnce it gets to byte 15...<br/>\r\n1. The two <code>LOAD_NAME</code>s will execute<br/>\r\n2. <code>COMPARE_OP</code><br/>\r\n3. <code>POP_JUMP_IF_FALSE</code> will bleed through to <code>LOAD_NAME</code> until <code>x</code> = 5<br/>\r\n4. <code>LOAD_NAME</code>, <code>LOAD_CONST</code>, <code>INPLACE_ADD</code>, and <code>STORE_NAME</code> will execute to increment <code>x</code><br/>\r\n5. <code>JUMP_ABSOLUTE</code> will jump back to byte 15 to recheck the condition for the while loop.<br/>\r\nOnce <code>x</code> = 5, <code>POP_JUMP_IF_FALSE</code> will jump us to byte 40 to execute <code>POP_BLOCK</code>\r\nbefore cleaning up with <code>LOAD_CONST</code> and <code>RETURN_VALUE</code>\r\n</p>\r\n\r\n<h1 id=\"Core\">Core Mechanics</h1>\r\n<h2 id=\"SETUP_LOOP\">SETUP_LOOP</h2>\r\n<p>\r\nAs you might be able to recall, <code>SETUP_LOOP</code> is defined in <code>ceval.c</code> and has the following\r\nkey line of code, which is defined in <code>frameobject.c</code>:\r\n<pre><code>\r\nPyFrame_BlockSetup(f, opcode, INSTR_OFFSET() + oparg, STACK_LEVEL());\r\n</code></pre>\r\n<p>\r\nThe arguments passed in are as follows:\r\n<code>f</code> is the frame object\r\n<code>opcode</code> ends up being the \"type\" of block that gets set up\r\n<code>INSTR_OFFSET() + oparg</code> ends up being used as the \"handler\", which is basically where to\r\njump to when the block is popped.\r\n<code>STACK_LEVEL()</code> is the level of the value stack to jump to once the block is popped\r\n</p>\r\n<p>\r\n<code>PyFrame_BlockSetup()</code> does a quick block stack overflow check to make sure that the new\r\nblock is allowed to exist by checking the current block number count, which is stored \r\nin the <code>f_iblock</code> field of the <code>PyFrameObject</code> struct, against the constant <code>CO_MAXBLOCKS</code>\r\ndefined in <code>code.h</code>, which is set to 20. If there are no problems, the a new block gets\r\nadded to the block stack (<code>f_blockstack[]</code>) that the frame object <code>f</code> keeps track of and\r\nits fields are set to the corresponding arguments passed in.\r\n</p>\r\n<h2 id=\"COMPARE_OP\">COMPARE_OP</h2>\r\n<p>\r\nHopefully, you remember the <code>COMPARE_OP</code> mechanism well enough, but we'll briefly go over\r\nit here.\r\nThe top value, in our case, <code>y</code>, is popped off and the next value, in our case, <code>x</code>, is peeked\r\nat to obtain its value. Once both values are obtained, Python checks to see if they're \r\nintegers (and they are):\r\n<pre><code>\r\nif (PyInt_CheckExact(w) && PyInt_CheckExact(v)) {\r\n  /* INLINE: cmp(int, int) */\r\n  register long a, b;\r\n  register int res;\r\n  a = PyInt_AS_LONG(v);\r\n  b = PyInt_AS_LONG(w);\r\n  switch (oparg) {\r\n    ...\r\n  }\r\n}\r\n...\r\n</code></pre>\r\n<p>\r\nThis is because comparing integers is really quick. Comparing integers involves\r\nputting the two numbers through the addition hardware circuit in the ALU. The second number is\r\nnegated by flipping all of its bits and adding 1 to effectively convert to subtraction. The system\r\ncan then determine the outcome of the comparison from the registry flags that are raised after the\r\nsubtraction. Python ends up converting the two numbers to longs to prevent potential overflow.\r\nPython handles the integer comparison via a switch statement to see which compare operation\r\nshould be run and then runs it on the two longs and spits back the result as a Python boolean\r\n(<code>Py_True</code> or <code>Py_False</code>).\r\n</p>\r\n<p>\r\nTo finish up, <code>COMPARE_OP</code> replaces the top value on the stack with the result and predicts a\r\n<code>POP_JUMP_IF_FALSE</code> opcode to come next.\r\n</p>\r\n<h2 id=\"INPLACE_ADD\">INPLACE_ADD</h2>\r\n<p>\r\nThe setup for this is very similar to <code>COMPARE_OP</code>: the top value is popped off and the next value\r\nis peeked at. Python then checks to see if they are integers (which they are) before converting\r\nthem to longs and running basic addition. The interesting part is after the addition is finished,\r\nwe see a bitwise xor check between the sum <code>i</code> and the two numbers added <code>a</code> and <code>b</code>:\r\n</p>\r\n<pre><code>\r\nif ((i^a) &lt; 0 && (i^b) &lt; 0)\r\n</code></pre>\r\n<p>\r\nThis is to check for overflow because even 64-bit integers can overflow. There are two cases in\r\nwhich the addition can overflow: both numbers are positive or both numbers are negative.\r\nIn the positive case, under normal circumstances, two numbers added should produce a larger, but\r\nstill positive number, meaning that the highest-order bit is 0. So when xor'd with positive numbers,\r\nthe resulting number should remain positive. If the result ends up being negative, then xor would\r\ntoggle both a and b's highest-order bit from 0 to 1, which would instantly convert it to a negative\r\nnumber. If that happens, then we know for a fact that the operation overflowed.\r\n</p>\r\n<p>\r\nIn the negative case, under normal circumstances, two negative number should produce a larger\r\nnegative number. Thus, when xor'd with a and b, i, if it remains negative, would toggle a and b's\r\nhighest-order bit to 0, which would instantly convert them to positive numbers and thus pass the\r\n&lt; 0 test. Otherwise, if it overflows, the 65th bit would be chopped off due to the convention of\r\ntwo's complement numbers and the highest order bit would be a 0, so a and b's highest order bits\r\nwould remain 1 and fail the &lt; 0 test.\r\n</p>\r\n<p>\r\nBeyond that, our script would just exit the if with <code>i</code> casted to int, complete some book keeping with\r\nreference counters, replace the top of the stack with the value of <code>i</code> and <code>continue</code>.\r\n</p>\r\n\r\n<h1 id=\"Control\">Control Flow</h1>\r\n<p>\r\nThe while loop control flow is dominated by two opcodes: <code>POP_JUMP_IF_FALSE</code> and <code>JUMP_ABSOLUTE</code>.\r\nSince you are very familiar with this, I'll go over them only briefly.\r\n</p>\r\n\r\n<h2 id=\"POP_JUMP\">POP_JUMP_IF_FALSE</h2>\r\n<p>\r\n<code>POP_JUMP_IF_FALSE</code> is usually predicted with <code>PREDICT(POP_JUMP_IF_FALSE);</code>\r\nlike in <code>COMPARE_OP</code>. In our case, this opcode handles when the while condition is false and needs to\r\njump to the end of the block. The general mechanics are quite simple: if the value at the top of the\r\nstack is <code>Py_True</code>, then keep going with the next opcode. Otherwise, jump to the byte that is specified\r\nin the oparg. In our case, it jumps to byte 40, which is <code>POP_BLOCK</code>.\r\n</p>\r\n\r\n<h2 id=\"JUMP\">JUMP_ABSOLUTE</h2>\r\n<p>\r\nThis happens at the end of the tryblock to jump back to the while loop's conditional. It jumps to the\r\nbyte specified with the oparg.\r\n</p>\r\n\r\n<h1 id=\"Clean\">Clean Up</h1>\r\n\r\n<h2 id=\"POP_BLOCK\">POP_BLOCK</h2>\r\n<p>\r\nPops off the block with <code>PyFrame_BlockPop()</code>, which is defined in frameobject.c. This basically reverses\r\nwhat <code>PyFrame_BlockSetup()</code> does, including a stack underflow check to make sure the stack count doesn't\r\ngo below 0.\r\n</p>\r\n<p>\r\nAll other opcodes are trivial.\r\n</p>\r\n</body>\r\n</html>","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}